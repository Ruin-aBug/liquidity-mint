// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts"

export class AmmCreated extends ethereum.Event {
  get params(): AmmCreated__Params {
    return new AmmCreated__Params(this)
  }
}

export class AmmCreated__Params {
  _event: AmmCreated

  constructor(event: AmmCreated) {
    this._event = event
  }

  get amm(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class AmmImplementationUpdated extends ethereum.Event {
  get params(): AmmImplementationUpdated__Params {
    return new AmmImplementationUpdated__Params(this)
  }
}

export class AmmImplementationUpdated__Params {
  _event: AmmImplementationUpdated

  constructor(event: AmmImplementationUpdated) {
    this._event = event
  }

  get newAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class CodeAddressUpdated extends ethereum.Event {
  get params(): CodeAddressUpdated__Params {
    return new CodeAddressUpdated__Params(this)
  }
}

export class CodeAddressUpdated__Params {
  _event: CodeAddressUpdated

  constructor(event: CodeAddressUpdated) {
    this._event = event
  }

  get newAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class MarketCreated extends ethereum.Event {
  get params(): MarketCreated__Params {
    return new MarketCreated__Params(this)
  }
}

export class MarketCreated__Params {
  _event: MarketCreated

  constructor(event: MarketCreated) {
    this._event = event
  }

  get name(): string {
    return this._event.parameters[0].value.toString()
  }

  get newAddress(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get marketIndex(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class MarketDestroyed extends ethereum.Event {
  get params(): MarketDestroyed__Params {
    return new MarketDestroyed__Params(this)
  }
}

export class MarketDestroyed__Params {
  _event: MarketDestroyed

  constructor(event: MarketDestroyed) {
    this._event = event
  }

  get market(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class MarketImplementationUpdated extends ethereum.Event {
  get params(): MarketImplementationUpdated__Params {
    return new MarketImplementationUpdated__Params(this)
  }
}

export class MarketImplementationUpdated__Params {
  _event: MarketImplementationUpdated

  constructor(event: MarketImplementationUpdated) {
    this._event = event
  }

  get newAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this)
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred

  constructor(event: OwnershipTransferred) {
    this._event = event
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress()
  }
}

export class TokenImplementationUpdated extends ethereum.Event {
  get params(): TokenImplementationUpdated__Params {
    return new TokenImplementationUpdated__Params(this)
  }
}

export class TokenImplementationUpdated__Params {
  _event: TokenImplementationUpdated

  constructor(event: TokenImplementationUpdated) {
    this._event = event
  }

  get newAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class TokensRecovered extends ethereum.Event {
  get params(): TokensRecovered__Params {
    return new TokensRecovered__Params(this)
  }
}

export class TokensRecovered__Params {
  _event: TokensRecovered

  constructor(event: TokensRecovered) {
    this._event = event
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class MarketsRegistry extends ethereum.SmartContract {
  static bind(address: Address): MarketsRegistry {
    return new MarketsRegistry("MarketsRegistry", address)
  }

  ammImplementation(): Address {
    let result = super.call(
      "ammImplementation",
      "ammImplementation():(address)",
      [],
    )

    return result[0].toAddress()
  }

  try_ammImplementation(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "ammImplementation",
      "ammImplementation():(address)",
      [],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  amms(param0: Bytes): Address {
    let result = super.call("amms", "amms(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0),
    ])

    return result[0].toAddress()
  }

  try_amms(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("amms", "amms(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  getLogicAddress(): Address {
    let result = super.call(
      "getLogicAddress",
      "getLogicAddress():(address)",
      [],
    )

    return result[0].toAddress()
  }

  try_getLogicAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getLogicAddress",
      "getLogicAddress():(address)",
      [],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  marketImplementation(): Address {
    let result = super.call(
      "marketImplementation",
      "marketImplementation():(address)",
      [],
    )

    return result[0].toAddress()
  }

  try_marketImplementation(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "marketImplementation",
      "marketImplementation():(address)",
      [],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  markets(param0: string): Address {
    let result = super.call("markets", "markets(string):(address)", [
      ethereum.Value.fromString(param0),
    ])

    return result[0].toAddress()
  }

  try_markets(param0: string): ethereum.CallResult<Address> {
    let result = super.tryCall("markets", "markets(string):(address)", [
      ethereum.Value.fromString(param0),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", [])

    return result[0].toAddress()
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  proxiableUUID(): Bytes {
    let result = super.call("proxiableUUID", "proxiableUUID():(bytes32)", [])

    return result[0].toBytes()
  }

  try_proxiableUUID(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("proxiableUUID", "proxiableUUID():(bytes32)", [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBytes())
  }

  tokenImplementation(): Address {
    let result = super.call(
      "tokenImplementation",
      "tokenImplementation():(address)",
      [],
    )

    return result[0].toAddress()
  }

  try_tokenImplementation(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "tokenImplementation",
      "tokenImplementation():(address)",
      [],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  createMarket(
    _marketName: string,
    _collateralToken: Address,
    _paymentToken: Address,
    _marketStyle: i32,
    _priceRatio: BigInt,
    _expirationDate: BigInt,
    _exerciseFeeBasisPoints: i32,
    _closeFeeBasisPoints: i32,
    _claimFeeBasisPoints: i32,
    _amm: Address,
  ): Address {
    let result = super.call(
      "createMarket",
      "createMarket(string,address,address,uint8,uint256,uint256,uint16,uint16,uint16,address):(address)",
      [
        ethereum.Value.fromString(_marketName),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_paymentToken),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_marketStyle)),
        ethereum.Value.fromUnsignedBigInt(_priceRatio),
        ethereum.Value.fromUnsignedBigInt(_expirationDate),
        ethereum.Value.fromUnsignedBigInt(
          BigInt.fromI32(_exerciseFeeBasisPoints),
        ),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_closeFeeBasisPoints)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_claimFeeBasisPoints)),
        ethereum.Value.fromAddress(_amm),
      ],
    )

    return result[0].toAddress()
  }

  try_createMarket(
    _marketName: string,
    _collateralToken: Address,
    _paymentToken: Address,
    _marketStyle: i32,
    _priceRatio: BigInt,
    _expirationDate: BigInt,
    _exerciseFeeBasisPoints: i32,
    _closeFeeBasisPoints: i32,
    _claimFeeBasisPoints: i32,
    _amm: Address,
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "createMarket",
      "createMarket(string,address,address,uint8,uint256,uint256,uint16,uint16,uint16,address):(address)",
      [
        ethereum.Value.fromString(_marketName),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_paymentToken),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_marketStyle)),
        ethereum.Value.fromUnsignedBigInt(_priceRatio),
        ethereum.Value.fromUnsignedBigInt(_expirationDate),
        ethereum.Value.fromUnsignedBigInt(
          BigInt.fromI32(_exerciseFeeBasisPoints),
        ),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_closeFeeBasisPoints)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_claimFeeBasisPoints)),
        ethereum.Value.fromAddress(_amm),
      ],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  createAmm(
    _priceOracle: Address,
    _paymentToken: Address,
    _collateralToken: Address,
    _tradeFeeBasisPoints: i32,
    _shouldInvertOraclePrice: boolean,
  ): Address {
    let result = super.call(
      "createAmm",
      "createAmm(address,address,address,uint16,bool):(address)",
      [
        ethereum.Value.fromAddress(_priceOracle),
        ethereum.Value.fromAddress(_paymentToken),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_tradeFeeBasisPoints)),
        ethereum.Value.fromBoolean(_shouldInvertOraclePrice),
      ],
    )

    return result[0].toAddress()
  }

  try_createAmm(
    _priceOracle: Address,
    _paymentToken: Address,
    _collateralToken: Address,
    _tradeFeeBasisPoints: i32,
    _shouldInvertOraclePrice: boolean,
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "createAmm",
      "createAmm(address,address,address,uint16,bool):(address)",
      [
        ethereum.Value.fromAddress(_priceOracle),
        ethereum.Value.fromAddress(_paymentToken),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_tradeFeeBasisPoints)),
        ethereum.Value.fromBoolean(_shouldInvertOraclePrice),
      ],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  getMarketsByAssetPair(assetPair: Bytes): Array<Address> {
    let result = super.call(
      "getMarketsByAssetPair",
      "getMarketsByAssetPair(bytes32):(address[])",
      [ethereum.Value.fromFixedBytes(assetPair)],
    )

    return result[0].toAddressArray()
  }

  try_getMarketsByAssetPair(
    assetPair: Bytes,
  ): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "getMarketsByAssetPair",
      "getMarketsByAssetPair(bytes32):(address[])",
      [ethereum.Value.fromFixedBytes(assetPair)],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddressArray())
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this)
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this)
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall

  constructor(call: RenounceOwnershipCall) {
    this._call = call
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall

  constructor(call: RenounceOwnershipCall) {
    this._call = call
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this)
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this)
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall

  constructor(call: TransferOwnershipCall) {
    this._call = call
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress()
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall

  constructor(call: TransferOwnershipCall) {
    this._call = call
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this)
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this)
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall

  constructor(call: InitializeCall) {
    this._call = call
  }

  get _tokenImplementation(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _marketImplementation(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get _ammImplementation(): Address {
    return this._call.inputValues[2].value.toAddress()
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall

  constructor(call: InitializeCall) {
    this._call = call
  }
}

export class UpdateTokenImplementationCall extends ethereum.Call {
  get inputs(): UpdateTokenImplementationCall__Inputs {
    return new UpdateTokenImplementationCall__Inputs(this)
  }

  get outputs(): UpdateTokenImplementationCall__Outputs {
    return new UpdateTokenImplementationCall__Outputs(this)
  }
}

export class UpdateTokenImplementationCall__Inputs {
  _call: UpdateTokenImplementationCall

  constructor(call: UpdateTokenImplementationCall) {
    this._call = call
  }

  get newTokenImplementation(): Address {
    return this._call.inputValues[0].value.toAddress()
  }
}

export class UpdateTokenImplementationCall__Outputs {
  _call: UpdateTokenImplementationCall

  constructor(call: UpdateTokenImplementationCall) {
    this._call = call
  }
}

export class UpdateMarketImplementationCall extends ethereum.Call {
  get inputs(): UpdateMarketImplementationCall__Inputs {
    return new UpdateMarketImplementationCall__Inputs(this)
  }

  get outputs(): UpdateMarketImplementationCall__Outputs {
    return new UpdateMarketImplementationCall__Outputs(this)
  }
}

export class UpdateMarketImplementationCall__Inputs {
  _call: UpdateMarketImplementationCall

  constructor(call: UpdateMarketImplementationCall) {
    this._call = call
  }

  get newMarketImplementation(): Address {
    return this._call.inputValues[0].value.toAddress()
  }
}

export class UpdateMarketImplementationCall__Outputs {
  _call: UpdateMarketImplementationCall

  constructor(call: UpdateMarketImplementationCall) {
    this._call = call
  }
}

export class updateAmmImplementationCall extends ethereum.Call {
  get inputs(): updateAmmImplementationCall__Inputs {
    return new updateAmmImplementationCall__Inputs(this)
  }

  get outputs(): updateAmmImplementationCall__Outputs {
    return new updateAmmImplementationCall__Outputs(this)
  }
}

export class updateAmmImplementationCall__Inputs {
  _call: updateAmmImplementationCall

  constructor(call: updateAmmImplementationCall) {
    this._call = call
  }

  get newAmmImplementation(): Address {
    return this._call.inputValues[0].value.toAddress()
  }
}

export class updateAmmImplementationCall__Outputs {
  _call: updateAmmImplementationCall

  constructor(call: updateAmmImplementationCall) {
    this._call = call
  }
}

export class UpdateMarketsRegistryImplementationCall extends ethereum.Call {
  get inputs(): UpdateMarketsRegistryImplementationCall__Inputs {
    return new UpdateMarketsRegistryImplementationCall__Inputs(this)
  }

  get outputs(): UpdateMarketsRegistryImplementationCall__Outputs {
    return new UpdateMarketsRegistryImplementationCall__Outputs(this)
  }
}

export class UpdateMarketsRegistryImplementationCall__Inputs {
  _call: UpdateMarketsRegistryImplementationCall

  constructor(call: UpdateMarketsRegistryImplementationCall) {
    this._call = call
  }

  get newMarketsRegistryImplementation(): Address {
    return this._call.inputValues[0].value.toAddress()
  }
}

export class UpdateMarketsRegistryImplementationCall__Outputs {
  _call: UpdateMarketsRegistryImplementationCall

  constructor(call: UpdateMarketsRegistryImplementationCall) {
    this._call = call
  }
}

export class UpdateImplementationForMarketCall extends ethereum.Call {
  get inputs(): UpdateImplementationForMarketCall__Inputs {
    return new UpdateImplementationForMarketCall__Inputs(this)
  }

  get outputs(): UpdateImplementationForMarketCall__Outputs {
    return new UpdateImplementationForMarketCall__Outputs(this)
  }
}

export class UpdateImplementationForMarketCall__Inputs {
  _call: UpdateImplementationForMarketCall

  constructor(call: UpdateImplementationForMarketCall) {
    this._call = call
  }

  get market(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get newMarketImplementation(): Address {
    return this._call.inputValues[1].value.toAddress()
  }
}

export class UpdateImplementationForMarketCall__Outputs {
  _call: UpdateImplementationForMarketCall

  constructor(call: UpdateImplementationForMarketCall) {
    this._call = call
  }
}

export class CreateMarketCall extends ethereum.Call {
  get inputs(): CreateMarketCall__Inputs {
    return new CreateMarketCall__Inputs(this)
  }

  get outputs(): CreateMarketCall__Outputs {
    return new CreateMarketCall__Outputs(this)
  }
}

export class CreateMarketCall__Inputs {
  _call: CreateMarketCall

  constructor(call: CreateMarketCall) {
    this._call = call
  }

  get _marketName(): string {
    return this._call.inputValues[0].value.toString()
  }

  get _collateralToken(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get _paymentToken(): Address {
    return this._call.inputValues[2].value.toAddress()
  }

  get _marketStyle(): i32 {
    return this._call.inputValues[3].value.toI32()
  }

  get _priceRatio(): BigInt {
    return this._call.inputValues[4].value.toBigInt()
  }

  get _expirationDate(): BigInt {
    return this._call.inputValues[5].value.toBigInt()
  }

  get _exerciseFeeBasisPoints(): i32 {
    return this._call.inputValues[6].value.toI32()
  }

  get _closeFeeBasisPoints(): i32 {
    return this._call.inputValues[7].value.toI32()
  }

  get _claimFeeBasisPoints(): i32 {
    return this._call.inputValues[8].value.toI32()
  }

  get _amm(): Address {
    return this._call.inputValues[9].value.toAddress()
  }
}

export class CreateMarketCall__Outputs {
  _call: CreateMarketCall

  constructor(call: CreateMarketCall) {
    this._call = call
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress()
  }
}

export class CreateAmmCall extends ethereum.Call {
  get inputs(): CreateAmmCall__Inputs {
    return new CreateAmmCall__Inputs(this)
  }

  get outputs(): CreateAmmCall__Outputs {
    return new CreateAmmCall__Outputs(this)
  }
}

export class CreateAmmCall__Inputs {
  _call: CreateAmmCall

  constructor(call: CreateAmmCall) {
    this._call = call
  }

  get _priceOracle(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _paymentToken(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get _collateralToken(): Address {
    return this._call.inputValues[2].value.toAddress()
  }

  get _tradeFeeBasisPoints(): i32 {
    return this._call.inputValues[3].value.toI32()
  }

  get _shouldInvertOraclePrice(): boolean {
    return this._call.inputValues[4].value.toBoolean()
  }
}

export class CreateAmmCall__Outputs {
  _call: CreateAmmCall

  constructor(call: CreateAmmCall) {
    this._call = call
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress()
  }
}

export class SelfDestructMarketCall extends ethereum.Call {
  get inputs(): SelfDestructMarketCall__Inputs {
    return new SelfDestructMarketCall__Inputs(this)
  }

  get outputs(): SelfDestructMarketCall__Outputs {
    return new SelfDestructMarketCall__Outputs(this)
  }
}

export class SelfDestructMarketCall__Inputs {
  _call: SelfDestructMarketCall

  constructor(call: SelfDestructMarketCall) {
    this._call = call
  }

  get market(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get refundAddress(): Address {
    return this._call.inputValues[1].value.toAddress()
  }
}

export class SelfDestructMarketCall__Outputs {
  _call: SelfDestructMarketCall

  constructor(call: SelfDestructMarketCall) {
    this._call = call
  }
}

export class RecoverTokensCall extends ethereum.Call {
  get inputs(): RecoverTokensCall__Inputs {
    return new RecoverTokensCall__Inputs(this)
  }

  get outputs(): RecoverTokensCall__Outputs {
    return new RecoverTokensCall__Outputs(this)
  }
}

export class RecoverTokensCall__Inputs {
  _call: RecoverTokensCall

  constructor(call: RecoverTokensCall) {
    this._call = call
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get destination(): Address {
    return this._call.inputValues[1].value.toAddress()
  }
}

export class RecoverTokensCall__Outputs {
  _call: RecoverTokensCall

  constructor(call: RecoverTokensCall) {
    this._call = call
  }
}
