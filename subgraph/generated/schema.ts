// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts"

export class Market extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save Market entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Market entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("Market", id.toString(), this)
  }

  static load(id: string): Market | null {
    return store.get("Market", id) as Market | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get createdBlock(): BigInt {
    let value = this.get("createdBlock")
    return value.toBigInt()
  }

  set createdBlock(value: BigInt) {
    this.set("createdBlock", Value.fromBigInt(value))
  }

  get createdTimestamp(): BigInt {
    let value = this.get("createdTimestamp")
    return value.toBigInt()
  }

  set createdTimestamp(value: BigInt) {
    this.set("createdTimestamp", Value.fromBigInt(value))
  }

  get createdTransaction(): Bytes {
    let value = this.get("createdTransaction")
    return value.toBytes()
  }

  set createdTransaction(value: Bytes) {
    this.set("createdTransaction", Value.fromBytes(value))
  }

  get marketName(): string {
    let value = this.get("marketName")
    return value.toString()
  }

  set marketName(value: string) {
    this.set("marketName", Value.fromString(value))
  }

  get marketIndex(): BigInt {
    let value = this.get("marketIndex")
    return value.toBigInt()
  }

  set marketIndex(value: BigInt) {
    this.set("marketIndex", Value.fromBigInt(value))
  }

  get collateralToken(): string | null {
    let value = this.get("collateralToken")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set collateralToken(value: string | null) {
    if (value === null) {
      this.unset("collateralToken")
    } else {
      this.set("collateralToken", Value.fromString(value as string))
    }
  }

  get paymentToken(): string | null {
    let value = this.get("paymentToken")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set paymentToken(value: string | null) {
    if (value === null) {
      this.unset("paymentToken")
    } else {
      this.set("paymentToken", Value.fromString(value as string))
    }
  }

  get marketStyle(): string | null {
    let value = this.get("marketStyle")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set marketStyle(value: string | null) {
    if (value === null) {
      this.unset("marketStyle")
    } else {
      this.set("marketStyle", Value.fromString(value as string))
    }
  }

  get amm(): string {
    let value = this.get("amm")
    return value.toString()
  }

  set amm(value: string) {
    this.set("amm", Value.fromString(value))
  }

  get priceRatio(): BigInt | null {
    let value = this.get("priceRatio")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set priceRatio(value: BigInt | null) {
    if (value === null) {
      this.unset("priceRatio")
    } else {
      this.set("priceRatio", Value.fromBigInt(value as BigInt))
    }
  }

  get expirationDate(): BigInt | null {
    let value = this.get("expirationDate")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set expirationDate(value: BigInt | null) {
    if (value === null) {
      this.unset("expirationDate")
    } else {
      this.set("expirationDate", Value.fromBigInt(value as BigInt))
    }
  }

  get exerciseFeeBasisPoints(): i32 {
    let value = this.get("exerciseFeeBasisPoints")
    return value.toI32()
  }

  set exerciseFeeBasisPoints(value: i32) {
    this.set("exerciseFeeBasisPoints", Value.fromI32(value))
  }

  get closeFeeBasisPoints(): i32 {
    let value = this.get("closeFeeBasisPoints")
    return value.toI32()
  }

  set closeFeeBasisPoints(value: i32) {
    this.set("closeFeeBasisPoints", Value.fromI32(value))
  }

  get claimFeeBasisPoints(): i32 {
    let value = this.get("claimFeeBasisPoints")
    return value.toI32()
  }

  set claimFeeBasisPoints(value: i32) {
    this.set("claimFeeBasisPoints", Value.fromI32(value))
  }

  get wToken(): string | null {
    let value = this.get("wToken")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set wToken(value: string | null) {
    if (value === null) {
      this.unset("wToken")
    } else {
      this.set("wToken", Value.fromString(value as string))
    }
  }

  get bToken(): string | null {
    let value = this.get("bToken")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set bToken(value: string | null) {
    if (value === null) {
      this.unset("bToken")
    } else {
      this.set("bToken", Value.fromString(value as string))
    }
  }

  get destroyed(): boolean {
    let value = this.get("destroyed")
    return value.toBoolean()
  }

  set destroyed(value: boolean) {
    this.set("destroyed", Value.fromBoolean(value))
  }

  get events(): Array<string> {
    let value = this.get("events")
    return value.toStringArray()
  }

  set events(value: Array<string>) {
    this.set("events", Value.fromStringArray(value))
  }
}

export class Fee extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save Fee entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Fee entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("Fee", id.toString(), this)
  }

  static load(id: string): Fee | null {
    return store.get("Fee", id) as Fee | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get market(): string {
    let value = this.get("market")
    return value.toString()
  }

  set market(value: string) {
    this.set("market", Value.fromString(value))
  }

  get feeType(): string | null {
    let value = this.get("feeType")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set feeType(value: string | null) {
    if (value === null) {
      this.unset("feeType")
    } else {
      this.set("feeType", Value.fromString(value as string))
    }
  }

  get token(): string {
    let value = this.get("token")
    return value.toString()
  }

  set token(value: string) {
    this.set("token", Value.fromString(value))
  }

  get value(): BigInt {
    let value = this.get("value")
    return value.toBigInt()
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value))
  }
}

export class MarketDestruction extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save MarketDestruction entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MarketDestruction entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("MarketDestruction", id.toString(), this)
  }

  static load(id: string): MarketDestruction | null {
    return store.get("MarketDestruction", id) as MarketDestruction | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get market(): string {
    let value = this.get("market")
    return value.toString()
  }

  set market(value: string) {
    this.set("market", Value.fromString(value))
  }
}

export class MarketInitialization extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save MarketInitialization entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MarketInitialization entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("MarketInitialization", id.toString(), this)
  }

  static load(id: string): MarketInitialization | null {
    return store.get("MarketInitialization", id) as MarketInitialization | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get market(): string {
    let value = this.get("market")
    return value.toString()
  }

  set market(value: string) {
    this.set("market", Value.fromString(value))
  }

  get wToken(): Bytes {
    let value = this.get("wToken")
    return value.toBytes()
  }

  set wToken(value: Bytes) {
    this.set("wToken", Value.fromBytes(value))
  }

  get bToken(): Bytes {
    let value = this.get("bToken")
    return value.toBytes()
  }

  set bToken(value: Bytes) {
    this.set("bToken", Value.fromBytes(value))
  }
}

export class OptionClose extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save OptionClose entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save OptionClose entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("OptionClose", id.toString(), this)
  }

  static load(id: string): OptionClose | null {
    return store.get("OptionClose", id) as OptionClose | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get market(): string {
    let value = this.get("market")
    return value.toString()
  }

  set market(value: string) {
    this.set("market", Value.fromString(value))
  }

  get eventType(): string {
    let value = this.get("eventType")
    return value.toString()
  }

  set eventType(value: string) {
    this.set("eventType", Value.fromString(value))
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get value(): BigInt {
    let value = this.get("value")
    return value.toBigInt()
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value))
  }

  get redeemer(): Bytes {
    let value = this.get("redeemer")
    return value.toBytes()
  }

  set redeemer(value: Bytes) {
    this.set("redeemer", Value.fromBytes(value))
  }
}

export class OptionExercise extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save OptionExercise entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save OptionExercise entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("OptionExercise", id.toString(), this)
  }

  static load(id: string): OptionExercise | null {
    return store.get("OptionExercise", id) as OptionExercise | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get market(): string {
    let value = this.get("market")
    return value.toString()
  }

  set market(value: string) {
    this.set("market", Value.fromString(value))
  }

  get eventType(): string {
    let value = this.get("eventType")
    return value.toString()
  }

  set eventType(value: string) {
    this.set("eventType", Value.fromString(value))
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get value(): BigInt {
    let value = this.get("value")
    return value.toBigInt()
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value))
  }

  get redeemer(): Bytes {
    let value = this.get("redeemer")
    return value.toBytes()
  }

  set redeemer(value: Bytes) {
    this.set("redeemer", Value.fromBytes(value))
  }
}

export class OptionMint extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save OptionMint entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save OptionMint entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("OptionMint", id.toString(), this)
  }

  static load(id: string): OptionMint | null {
    return store.get("OptionMint", id) as OptionMint | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get market(): string {
    let value = this.get("market")
    return value.toString()
  }

  set market(value: string) {
    this.set("market", Value.fromString(value))
  }

  get eventType(): string {
    let value = this.get("eventType")
    return value.toString()
  }

  set eventType(value: string) {
    this.set("eventType", Value.fromString(value))
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get value(): BigInt {
    let value = this.get("value")
    return value.toBigInt()
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value))
  }

  get minter(): Bytes {
    let value = this.get("minter")
    return value.toBytes()
  }

  set minter(value: Bytes) {
    this.set("minter", Value.fromBytes(value))
  }
}

export class OptionCollateralClaim extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(
      id !== null,
      "Cannot save OptionCollateralClaim entity without an ID",
    )
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save OptionCollateralClaim entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("OptionCollateralClaim", id.toString(), this)
  }

  static load(id: string): OptionCollateralClaim | null {
    return store.get(
      "OptionCollateralClaim",
      id,
    ) as OptionCollateralClaim | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get market(): string {
    let value = this.get("market")
    return value.toString()
  }

  set market(value: string) {
    this.set("market", Value.fromString(value))
  }

  get eventType(): string {
    let value = this.get("eventType")
    return value.toString()
  }

  set eventType(value: string) {
    this.set("eventType", Value.fromString(value))
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get value(): BigInt {
    let value = this.get("value")
    return value.toBigInt()
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value))
  }

  get redeemer(): Bytes {
    let value = this.get("redeemer")
    return value.toBytes()
  }

  set redeemer(value: Bytes) {
    this.set("redeemer", Value.fromBytes(value))
  }
}

export class Amm extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save Amm entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Amm entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("Amm", id.toString(), this)
  }

  static load(id: string): Amm | null {
    return store.get("Amm", id) as Amm | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get createdBlock(): BigInt {
    let value = this.get("createdBlock")
    return value.toBigInt()
  }

  set createdBlock(value: BigInt) {
    this.set("createdBlock", Value.fromBigInt(value))
  }

  get createdTimestamp(): BigInt {
    let value = this.get("createdTimestamp")
    return value.toBigInt()
  }

  set createdTimestamp(value: BigInt) {
    this.set("createdTimestamp", Value.fromBigInt(value))
  }

  get createdTransaction(): Bytes {
    let value = this.get("createdTransaction")
    return value.toBytes()
  }

  set createdTransaction(value: Bytes) {
    this.set("createdTransaction", Value.fromBytes(value))
  }

  get markets(): Array<string | null> {
    let value = this.get("markets")
    return value.toStringArray()
  }

  set markets(value: Array<string | null>) {
    this.set("markets", Value.fromStringArray(value))
  }

  get registry(): Bytes {
    let value = this.get("registry")
    return value.toBytes()
  }

  set registry(value: Bytes) {
    this.set("registry", Value.fromBytes(value))
  }

  get priceOracle(): Bytes {
    let value = this.get("priceOracle")
    return value.toBytes()
  }

  set priceOracle(value: Bytes) {
    this.set("priceOracle", Value.fromBytes(value))
  }

  get paymentToken(): string {
    let value = this.get("paymentToken")
    return value.toString()
  }

  set paymentToken(value: string) {
    this.set("paymentToken", Value.fromString(value))
  }

  get collateralToken(): string {
    let value = this.get("collateralToken")
    return value.toString()
  }

  set collateralToken(value: string) {
    this.set("collateralToken", Value.fromString(value))
  }

  get tradeFeeBasisPoints(): i32 {
    let value = this.get("tradeFeeBasisPoints")
    return value.toI32()
  }

  set tradeFeeBasisPoints(value: i32) {
    this.set("tradeFeeBasisPoints", Value.fromI32(value))
  }

  get lpToken(): string {
    let value = this.get("lpToken")
    return value.toString()
  }

  set lpToken(value: string) {
    this.set("lpToken", Value.fromString(value))
  }

  get assetPair(): Bytes {
    let value = this.get("assetPair")
    return value.toBytes()
  }

  set assetPair(value: Bytes) {
    this.set("assetPair", Value.fromBytes(value))
  }
}

export class Token extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save Token entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Token entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("Token", id.toString(), this)
  }

  static load(id: string): Token | null {
    return store.get("Token", id) as Token | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get market(): string | null {
    let value = this.get("market")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set market(value: string | null) {
    if (value === null) {
      this.unset("market")
    } else {
      this.set("market", Value.fromString(value as string))
    }
  }

  get type(): string | null {
    let value = this.get("type")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set type(value: string | null) {
    if (value === null) {
      this.unset("type")
    } else {
      this.set("type", Value.fromString(value as string))
    }
  }

  get decimals(): i32 {
    let value = this.get("decimals")
    return value.toI32()
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value))
  }

  get name(): string {
    let value = this.get("name")
    return value.toString()
  }

  set name(value: string) {
    this.set("name", Value.fromString(value))
  }

  get symbol(): string {
    let value = this.get("symbol")
    return value.toString()
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value))
  }

  get totalSupply(): BigInt {
    let value = this.get("totalSupply")
    return value.toBigInt()
  }

  set totalSupply(value: BigInt) {
    this.set("totalSupply", Value.fromBigInt(value))
  }

  get totalBurned(): BigInt | null {
    let value = this.get("totalBurned")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set totalBurned(value: BigInt | null) {
    if (value === null) {
      this.unset("totalBurned")
    } else {
      this.set("totalBurned", Value.fromBigInt(value as BigInt))
    }
  }

  get totalMinted(): BigInt | null {
    let value = this.get("totalMinted")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set totalMinted(value: BigInt | null) {
    if (value === null) {
      this.unset("totalMinted")
    } else {
      this.set("totalMinted", Value.fromBigInt(value as BigInt))
    }
  }

  get totalTransferred(): BigInt | null {
    let value = this.get("totalTransferred")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set totalTransferred(value: BigInt | null) {
    if (value === null) {
      this.unset("totalTransferred")
    } else {
      this.set("totalTransferred", Value.fromBigInt(value as BigInt))
    }
  }

  get events(): Array<string> {
    let value = this.get("events")
    return value.toStringArray()
  }

  set events(value: Array<string>) {
    this.set("events", Value.fromStringArray(value))
  }
}

export class TokenTransfer extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save TokenTransfer entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TokenTransfer entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("TokenTransfer", id.toString(), this)
  }

  static load(id: string): TokenTransfer | null {
    return store.get("TokenTransfer", id) as TokenTransfer | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get token(): string {
    let value = this.get("token")
    return value.toString()
  }

  set token(value: string) {
    this.set("token", Value.fromString(value))
  }

  get amount(): BigInt {
    let value = this.get("amount")
    return value.toBigInt()
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value))
  }

  get sender(): Bytes {
    let value = this.get("sender")
    return value.toBytes()
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value))
  }

  get eventType(): string {
    let value = this.get("eventType")
    return value.toString()
  }

  set eventType(value: string) {
    this.set("eventType", Value.fromString(value))
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get from(): Bytes {
    let value = this.get("from")
    return value.toBytes()
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value))
  }

  get to(): Bytes {
    let value = this.get("to")
    return value.toBytes()
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value))
  }
}

export class TokenApproval extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save TokenApproval entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TokenApproval entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("TokenApproval", id.toString(), this)
  }

  static load(id: string): TokenApproval | null {
    return store.get("TokenApproval", id) as TokenApproval | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get token(): string {
    let value = this.get("token")
    return value.toString()
  }

  set token(value: string) {
    this.set("token", Value.fromString(value))
  }

  get amount(): BigInt {
    let value = this.get("amount")
    return value.toBigInt()
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value))
  }

  get sender(): Bytes {
    let value = this.get("sender")
    return value.toBytes()
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value))
  }

  get eventType(): string {
    let value = this.get("eventType")
    return value.toString()
  }

  set eventType(value: string) {
    this.set("eventType", Value.fromString(value))
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get owner(): Bytes {
    let value = this.get("owner")
    return value.toBytes()
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value))
  }

  get spender(): Bytes {
    let value = this.get("spender")
    return value.toBytes()
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value))
  }
}

export class TokenMint extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save TokenMint entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TokenMint entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("TokenMint", id.toString(), this)
  }

  static load(id: string): TokenMint | null {
    return store.get("TokenMint", id) as TokenMint | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get token(): string {
    let value = this.get("token")
    return value.toString()
  }

  set token(value: string) {
    this.set("token", Value.fromString(value))
  }

  get amount(): BigInt {
    let value = this.get("amount")
    return value.toBigInt()
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value))
  }

  get sender(): Bytes {
    let value = this.get("sender")
    return value.toBytes()
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value))
  }

  get eventType(): string {
    let value = this.get("eventType")
    return value.toString()
  }

  set eventType(value: string) {
    this.set("eventType", Value.fromString(value))
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get minter(): Bytes {
    let value = this.get("minter")
    return value.toBytes()
  }

  set minter(value: Bytes) {
    this.set("minter", Value.fromBytes(value))
  }

  get destination(): Bytes {
    let value = this.get("destination")
    return value.toBytes()
  }

  set destination(value: Bytes) {
    this.set("destination", Value.fromBytes(value))
  }
}

export class TokenBurn extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save TokenBurn entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TokenBurn entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("TokenBurn", id.toString(), this)
  }

  static load(id: string): TokenBurn | null {
    return store.get("TokenBurn", id) as TokenBurn | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get token(): string {
    let value = this.get("token")
    return value.toString()
  }

  set token(value: string) {
    this.set("token", Value.fromString(value))
  }

  get amount(): BigInt {
    let value = this.get("amount")
    return value.toBigInt()
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value))
  }

  get sender(): Bytes {
    let value = this.get("sender")
    return value.toBytes()
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value))
  }

  get eventType(): string {
    let value = this.get("eventType")
    return value.toString()
  }

  set eventType(value: string) {
    this.set("eventType", Value.fromString(value))
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get burner(): Bytes {
    let value = this.get("burner")
    return value.toBytes()
  }

  set burner(value: Bytes) {
    this.set("burner", Value.fromBytes(value))
  }
}

export class Account extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save Account entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Account entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("Account", id.toString(), this)
  }

  static load(id: string): Account | null {
    return store.get("Account", id) as Account | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get address(): Bytes {
    let value = this.get("address")
    return value.toBytes()
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value))
  }

  get balances(): Array<string> {
    let value = this.get("balances")
    return value.toStringArray()
  }

  set balances(value: Array<string>) {
    this.set("balances", Value.fromStringArray(value))
  }
}

export class AccountBalance extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(id !== null, "Cannot save AccountBalance entity without an ID")
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AccountBalance entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("AccountBalance", id.toString(), this)
  }

  static load(id: string): AccountBalance | null {
    return store.get("AccountBalance", id) as AccountBalance | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get account(): string {
    let value = this.get("account")
    return value.toString()
  }

  set account(value: string) {
    this.set("account", Value.fromString(value))
  }

  get token(): string {
    let value = this.get("token")
    return value.toString()
  }

  set token(value: string) {
    this.set("token", Value.fromString(value))
  }

  get amount(): BigInt {
    let value = this.get("amount")
    return value.toBigInt()
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value))
  }

  get block(): BigInt | null {
    let value = this.get("block")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set block(value: BigInt | null) {
    if (value === null) {
      this.unset("block")
    } else {
      this.set("block", Value.fromBigInt(value as BigInt))
    }
  }

  get modified(): BigInt | null {
    let value = this.get("modified")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set modified(value: BigInt | null) {
    if (value === null) {
      this.unset("modified")
    } else {
      this.set("modified", Value.fromBigInt(value as BigInt))
    }
  }

  get transaction(): Bytes | null {
    let value = this.get("transaction")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBytes()
    }
  }

  set transaction(value: Bytes | null) {
    if (value === null) {
      this.unset("transaction")
    } else {
      this.set("transaction", Value.fromBytes(value as Bytes))
    }
  }
}

export class AccountBalanceSnapshot extends Entity {
  constructor(id: string) {
    super()
    this.set("id", Value.fromString(id))
  }

  save(): void {
    let id = this.get("id")
    assert(
      id !== null,
      "Cannot save AccountBalanceSnapshot entity without an ID",
    )
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AccountBalanceSnapshot entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.',
    )
    store.set("AccountBalanceSnapshot", id.toString(), this)
  }

  static load(id: string): AccountBalanceSnapshot | null {
    return store.get(
      "AccountBalanceSnapshot",
      id,
    ) as AccountBalanceSnapshot | null
  }

  get id(): string {
    let value = this.get("id")
    return value.toString()
  }

  set id(value: string) {
    this.set("id", Value.fromString(value))
  }

  get account(): string {
    let value = this.get("account")
    return value.toString()
  }

  set account(value: string) {
    this.set("account", Value.fromString(value))
  }

  get token(): string {
    let value = this.get("token")
    return value.toString()
  }

  set token(value: string) {
    this.set("token", Value.fromString(value))
  }

  get amount(): BigInt {
    let value = this.get("amount")
    return value.toBigInt()
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value))
  }

  get event(): string | null {
    let value = this.get("event")
    if (value === null || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set event(value: string | null) {
    if (value === null) {
      this.unset("event")
    } else {
      this.set("event", Value.fromString(value as string))
    }
  }

  get block(): BigInt {
    let value = this.get("block")
    return value.toBigInt()
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp")
    return value.toBigInt()
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value))
  }

  get transaction(): Bytes {
    let value = this.get("transaction")
    return value.toBytes()
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value))
  }
}
